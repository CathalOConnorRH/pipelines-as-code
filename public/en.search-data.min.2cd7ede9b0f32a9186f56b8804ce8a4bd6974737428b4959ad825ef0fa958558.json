[{"id":0,"href":"/docs/install/github_apps/","title":"Github Apps","section":"Installation","content":"Create a Pipelines-as-Code GitHub App #  The GitHub App install is different than other install methods since it acts as the integration point with OpenShift Pipelines and brings the Git workflow into Tekton pipelines. You only need one GitHub App for every users on the cluster usually setup by the admin.\nYou need the webhook of the GitHub App to point to your Pipelines-as-Code Controller route/ingress endpoint which would listen to GitHub events.\nSetup #    Go to https://github.com/settings/apps (or Settings \u0026gt; Developer settings \u0026gt; GitHub Apps) and click on New GitHub App button\n  Provide the following info in the GitHub App form\n GitHub Application Name: OpenShift Pipelines Homepage URL: [OpenShift Console URL] Webhook URL: [the Pipelines as Code route/ingress URL as copied in the previous section] Webhook secret: [an arbitrary secret, you can generate one with openssl rand -hex 20]    Select the following repository permissions:\n Checks: Read \u0026amp; Write Contents: Read \u0026amp; Write Issues: Read \u0026amp; Write Metadata: Readonly Pull request: Read \u0026amp; Write    Select the following organization permissions:\n Members: Readonly Plan: Readonly    Select the following user permissions:\n Commit comment Issue comment Pull request Pull request review Pull request review comment Push     You can see a screenshot of how the GitHub App permissions look like here\n   Click on Create GitHub App.\n  Take note of the App ID at the top of the page on the details page of the GitHub App you just created.\n  In Private keys section, click on *Generate Private key to generate a private key for the GitHub app. It will download automatically. Store the private key in a safe place as you need it in the next section and in future when reconfiguring this app to use a different cluster.\n  Configure Pipelines-as-Code on your cluster to access the GitHub App #  In order for Pipelines-as-Code to be able to authenticate to the GitHub App and have the GitHub App securely trigger the Pipelines-as-Code webhook, you need to create a Kubernetes secret containing the private key of the GitHub App and the webhook secret of the Pipelines-as-Code as it was provided when you created the GitHub App in the previous section. This secret is used to generate a token on behalf of the user running the event and make sure to validate the webhook via the webhook secret.\nRun the following command and replace:\n APP_ID with the GitHub App App ID copied in the previous section WEBHOOK_SECRET with the webhook secret provided when created the GitHub App in the previous section PATH_PRIVATE_KEY with the path to the private key that was downloaded in the previous section  kubectl -n pipelines-as-code create secret generic pipelines-as-code-secret \\  --from-literal github-private-key=\u0026#34;$(cat PATH_PRIVATE_KEY)\u0026#34; \\  --from-literal github-application-id=\u0026#34;APP_ID\u0026#34; \\  --from-literal webhook.secret=\u0026#34;WEBHOOK_SECRET\u0026#34; GitHub Enterprise #  Pipelines as Code supports Github Enterprise.\nYou don\u0026rsquo;t need to do anything special to get Pipelines as code working with GHE. Pipelines as code will automatically detects the header as set from GHE and use it the GHE API auth url instead of the public github.\n"},{"id":1,"href":"/docs/install/","title":"Installation","section":"Docs","content":"Pipelines as Code - Installation #  Pipelines-as-Code support different installation method to Git provider platforms (i.e: GitHub, Bitbucket etc..)\nThe preferred method to use Pipelines-as-Code is configured with a GitHub Application.\nInstall Pipelines-as-Code #  In order to install and use Pipelines-as-Code, you need to\n Install the Pipelines-as-Code infrastructure on your cluster Configure your Git Provider (eg: a GitHub Application) to access Pipelines as Code.  Install Pipelines as Code infrastructure #  To install Pipelines as Code on your cluster you simply need to run this command :\nVERSION=0.5.3 kubectl apply -f https://raw.githubusercontent.com/openshift-pipelines/pipelines-as-code/release-$VERSION/release-$VERSION.yaml If you would like to install the current development version you can simply install it like this :\nkubectl apply -f https://raw.githubusercontent.com/openshift-pipelines/pipelines-as-code/nightly/release.yaml This will apply the release.yaml to your kubernetes cluster, creating the admin namespace pipelines-as-code, the roles and all other bits needed.\nThe pipelines-as-code namespace is where the Pipelines-as-Code infrastructure runs and is supposed to be accessible only by the admins.\nThe Route URL for the Pipelines as Code Controller is automatically created when you apply the release.yaml. You will need to reference this url when configuring your github provider.\nYou can run this command to get the route created on your cluster:\necho https://$(oc get route -n pipelines-as-code el-pipelines-as-code-interceptor -o jsonpath=\u0026#39;{.spec.host}\u0026#39;) RBAC #  Non system:admin users needs to be allowed explicitly to create repositories CRD in their namespace\nTo allow them you need to create a RoleBinding on the namespace to the openshift-pipeline-as-code-clusterrole.\nFor example assuming we want user being able to create repository CRD in the namespace user-ci, if we use the openshift oc cli :\noc adm policy add-role-to-user openshift-pipeline-as-code-clusterrole user -n user-ci or via kubectl applying this yaml :\napiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata:  name: openshift-pipeline-as-code-clusterrole  namespace: user-ci roleRef:  apiGroup: rbac.authorization.k8s.io  kind: ClusterRole  name: openshift-pipeline-as-code-clusterrole subjects: - apiGroup: rbac.authorization.k8s.io  kind: User  name: user Provider Setup #  After installing Pipelines as Code you are now ready to configure your Git provider. Choose your preferred install method, if you don\u0026rsquo;t have any preferences the preferred install method is the Github Application method.\n Github Application. Github Webhook Gitlab Bitbucket Server Bitbucket Cloud  Pipelines-As-Code configuration settings #  There is a few things you can configure via the configmap pipelines-as-code in the pipelines-as-code namespace.\n  application-name\nThe name of the application showing for example in the GitHub Checks labels. Default to \u0026quot;Pipelines as Code CI\u0026quot;\n  max-keep-days\nThe number of the day to keep the PipelineRuns runs in the pipelines-as-code namespace. We install by default a cronjob that cleans up the PipelineRuns generated on events in pipelines-as-code namespace. Note that these PipelineRuns are internal to Pipelines-as-code are separate from the PipelineRuns that exist in the user\u0026rsquo;s GitHub repository. The cronjob runs every hour and by default cleanups PipelineRuns over a day. This configmap setting doesn\u0026rsquo;t affect the cleanups of the user\u0026rsquo;s PipelineRuns which are controlled by the annotations on the PipelineRun definition in the user\u0026rsquo;s GitHub repository.\n  secret-auto-create\nWhether to auto create a secret with the token generated via the Github application to be used with private repositories. This feature is enabled by default.\n  remote-tasks\nLet allows remote tasks from pipelinerun annotations. This feature is enabled by default.\n  hub-url\nThe base url for the tekton hub API. default to the public hub:\nhttps://api.hub.tekton.dev/v1\n  Kubernetes #  Pipelines as Code should work directly on kubernetes/minikube/kind. You just need to install the release.yaml for pipeline , triggers and its interceptors on your cluster. The release yaml to install pipelines are for the released version :\nVERSION=0.5.3 kubectl apply -f https://raw.githubusercontent.com/openshift-pipelines/pipelines-as-code/release-$VERSION/release-$VERSION.k8s.yaml and for the nightly :\nkubectl apply -f https://raw.githubusercontent.com/openshift-pipelines/pipelines-as-code/release-$VERSION/release.k8s.yaml If you have Tekton Dashboard. You can just add the key tekton-dashboard-url in the pipelines-as-code configmap set to the full url of the Ingress host to get tekton dashboard logs url.\nCLI #  Pipelines as Code provide a CLI which is designed to work as tkn plugin. To install the plugin follow the instruction from the CLI documentation.\n"},{"id":2,"href":"/docs/install/github_webhook/","title":"Github Webhook","section":"Installation","content":"Install Pipelines-as-Code as a GitHub Webhook #  If you are not able to create a GitHub application you can install Pipelines-as-Code on your repository as a GitHub Webhook.\nUsing Pipelines as Code via Github webhook does not give you access to the GitHub CheckRun API, therefore the status of the tasks will be added as a Comment of the PR and not via the Checks Tab.\nFollowing the infrastructure installation\n  You will have to generate a personal token for Pipelines-as-Code Github API operations.\nFollow this guide to create a personal token :\n  https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token\nThe only permission needed is the repo permission. Make sure you note somewhere the generated token or otherwise you will have to recreate it.\n  Go to you repository or organization setting and click on Hooks and \u0026ldquo;Add webhook\u0026rdquo; links.\n  Set the payload URL to the event listener public URL. On OpenShift you can get the public URL of the Pipelines-as-Code controller like this :\necho https://$(oc get route -n pipelines-as-code el-pipelines-as-code-interceptor -o jsonpath=\u0026#39;{.spec.host}\u0026#39;)   Add a secret or generate a random one with this command :\nopenssl rand -hex 20   Refer to this screenshot on how to configure the Webhook. The individual events to select are :\n Commit comments Issue comments Pull request reviews Pull request Pushes    On your cluster you need create the webhook secret as generated previously in the pipelines-as-code namespace.\n  kubectl -n pipelines-as-code create secret generic pipelines-as-code-secret \\  --from-literal webhook.secret=\u0026#34;$WEBHOOK_SECRET_AS_GENERATED\u0026#34;   You are now able to create a Repository CRD. The repository CRD will have a Secret that contains the Personal token as generated and Pipelines as Code will know how to use it for GitHub API operations.\n  First create the secret with the personal token in the target-namespace :\nkubectl -n target-namespace create secret generic github-personal-token \\  --from-literal token=\u0026#34;TOKEN_AS_GENERATED_PREVIOUSLY\u0026#34;   And now create Repository CRD with the secret field referencing it.\n  Here is an example of a Repository CRD :\n--- apiVersion: \u0026#34;pipelinesascode.tekton.dev/v1alpha1\u0026#34; kind: Repository metadata:  name: my-repo  namespace: target-namespace spec:  url: \u0026#34;https://github.com/owner/repo\u0026#34;  git_provider:  url: \u0026#34;https://github.enterprise.com\u0026#34;  secret:  name: \u0026#34;github-personal-token\u0026#34;  # Set this if you have a different key in your secret  # key: \u0026#34;token\u0026#34;  Note that git_provider.secret cannot reference a secret in another namespace, Pipelines as code assumes always it will be the same namespace as where the repository has been created.  "},{"id":3,"href":"/docs/guide/","title":"Usage Guide","section":"Docs","content":"Pipeline as Code - Usage Guide #  Repository CRD #  The purposes of the Repository CRD is :\n To let Pipelines as Code know that this event from this URL needs to be handled. To let Pipelines as Code know on which namespace the PipelineRuns are going to be executed. To reference a api secret, username or api URL if needed for the git provider platforms that requires it (ie: when you are using webhooks method and not the github application). To give the last Pipelinerun status for that Repository (5 by default).  The flow looks like this :\nVia the tkn pac CLI or other method the user creates a Repository CR inside the target namespace my-pipeline-ci :\ncat \u0026lt;\u0026lt;EOF|kubectl create -n my-pipeline-ci -f- apiVersion: \u0026#34;pipelinesascode.tekton.dev/v1alpha1\u0026#34; kind: Repository metadata:  name: scratch-my-back spec:  url: \u0026#34;https://github.com/linda/project\u0026#34; EOF Whenever there is a event coming from github.com/linda/project Pipelines as Code will match it and starts checking out the content of the linda/project for pipelinerun to match in the .tekton/ directory.\nThe Repository CRD needs to be created in the namespace where Tekton Pipelines associated with the source code repository would be executed, it cannot target another namespace.\nIf there is multiples CRD matching the same event, only the oldest one will match. If you need to match a specific namespace you would need to use the target-namespace feature in the pipeline annotation (see below).\nThere is another optional layer of security where PipelineRun can have an annotation to explicitly target a specific namespace. It would still need to have a Repository CRD created in that namespace to be able to be matched.\nWith this annotation a bad actor on a cluster cannot hijack the pipelineRun execution to a namespace they don\u0026rsquo;t have access to. To use that feature you need to add this annotation to the pipeline annotation :\npipelinesascode.tekton.dev/target-namespace: \u0026#34;mynamespace\u0026#34; and Pipelines as Code will only match the repository in the mynamespace Namespace instead of trying to match it from all available repository on cluster.\nAuthoring PipelineRun in .tekton/ directory #    Pipelines as Code will always try to be as close to the tekton template as possible. Usually you will write your template and save them with a \u0026ldquo;.yaml\u0026rdquo; extension and Pipelines as Code will run them.\n  Inside your pipeline you need to be able to check out the commit as received from the webhook by checking it out the repository from that ref. You would usually use the git-clone task from catalog.\nTo be able to specify the parameters of your commit and url, Pipelines as Code allows you to have those \u0026ldquo;dynamic\u0026rdquo; variables expanded. Those variables look like this {{ var }}and those are the one you can use:\n {{repo_owner}}: The repository owner. {{repo_name}}: The repository name. {{repo_url}}: The repository full URL. {{revision}}: The commit full sha revision. {{sender}}: The sender username (or account id on some providers) of the commit. {{source_branch}}: The branch name where the event come from. {{target_branch}}: The branch name on which the event targets (same as source_branch for push events).    You need at least one PipelineRun with a PipelineSpec or a separated Pipeline object. You can have embedded TaskSpec inside Pipeline or you can have them defined separately as Task.\n  Examples #  Pipelines as code test itself, you can see the examples in its .tekton repository.\nEvent matching to a Pipeline #  Each PipelineRun can match different git provider events via some special annotations on the PipelineRun. For example when you have these metadatas in your PipelineRun:\n metadata:  name: pipeline-pr-main  annotations:  pipelinesascode.tekton.dev/on-target-branch: \u0026#34;[main]\u0026#34;  pipelinesascode.tekton.dev/on-event: \u0026#34;[pull_request]\u0026#34; Pipelines as Code will match the pipelinerun pipeline-pr-main if the git provider events target the branch main and it\u0026rsquo;s coming from a [pull_request]\nMultiple target branch can be specified separated by comma, i.e:\n[main, release-nightly]\nYou can match on pull_request events as above and you can as well match pipelineRuns on push events to a repository\nFor example this will match the pipeline when there is a push to a commit in the main branch :\n metadata:  name: pipeline-push-on-main  annotations:  pipelinesascode.tekton.dev/on-target-branch: \u0026#34;[refs/heads/main]\u0026#34;  pipelinesascode.tekton.dev/on-event: \u0026#34;[push]\u0026#34; You can specify the full refs like refs/heads/main or the shortref like main. You can as well specify globs, for example refs/heads/* will match any target branch or refs/tags/1.* will match all the tags starting from 1..\nA full example for a push of a tag :\n metadata:  name: pipeline-push-on-1.0-tags  annotations:  pipelinesascode.tekton.dev/on-target-branch: \u0026#34;[refs/tags/1.0]\u0026#34;  pipelinesascode.tekton.dev/on-event: \u0026#34;[push]\u0026#34; This will match the pipeline pipeline-push-on-1.0-tags when you push the 1.0 tags into your repository.\nMatching annotations are currently mandated or Pipelines as Code will not match your PipelineRun.\nIf there is multiple pipeline matching an event, it will match the first one. We are currently not supporting multiple PipelineRuns on a single event but this may be something we can consider to implement in the future.\nAdvanced event matching #  If you need to do some advanced matching, Pipelines as Code supports CEL filtering.\nIf you have the pipelinesascode.tekton.dev/on-cel-expression annotation in your PipelineRun, the CEL expression will be used and the on-target-branch or on-target-branch annotations will then be skipped.\nFor example :\n pipelinesascode.tekton.dev/on-cel-expression: | event == \u0026#34;pull_request\u0026#34; \u0026amp;\u0026amp; target_branch == \u0026#34;main\u0026#34; \u0026amp;\u0026amp; source_branch == \u0026#34;wip\u0026#34; will match a pull_request event targetting the branch main coming from a branch called wip.\nThe fields available are :\n event: push or pull_request target_branch: The branch we are targetting. source_branch: The branch where this pull_request come from. (on push this is the same as target_branch).  Compared to the simple \u0026ldquo;on-target\u0026rdquo; annotation matching, the CEL expression allows you to complex filtering and most importantly express negation.\nFor example if I want to have a PipelineRun targeting a pull_request but not the experimental branch I would have :\n pipelinesascode.tekton.dev/on-cel-expression: | event == \u0026#34;pull_request\u0026#34; \u0026amp;\u0026amp; target_branch != experimental\u0026#34; You can find more information about the CEL language spec here :\nhttps://github.com/google/cel-spec/blob/master/doc/langdef.md\nPipelineRuns Cleanups #  There can be a lot of PipelineRuns into an user namespace and Pipelines as Code has the ability to only keep a number of PipelineRuns that matches an event.\nFor example if the PipelineRun has this annotation :\npipelinesascode.tekton.dev/max-keep-runs: \u0026#34;maxNumber\u0026#34; Pipelines as Code sees this and will start cleaning up right after it finishes a successful execution keeping only the maxNumber of PipelineRuns.\nIt will skip the Running PipelineRuns but will not skip the PipelineRuns with Unknown status.\nPrivate repositories #  Pipelines as Code support private repositories by creating or updating a secret in the target namespace with the user token for the git-clone task to use and be able to clone private repositories.\nWhenever Pipelines as Code create a new PipelineRun in the target namespace it will create or update a secret called :\npac-git-basic-auth-REPOSITORY_OWNER-REPOSITORY_NAME\nThe secret contains a .gitconfig and a git credentials .git-credentials with the https url using the token it discovered from the Github application or attached to the secret.\nAs documented :\nhttps://github.com/tektoncd/catalog/blob/main/task/git-clone/0.4/README.md\nthe secret needs to be referenced inside your PipelineRun and Pipeline as a workspace called basic-auth to be passed to the git-clone task.\nFor example in your PipelineRun you will add the workspace referencing the Secret :\n workspace:  - name: basic-auth  secret:  secretName: \u0026#34;pac-git-basic-auth-{{repo_owner}}-{{repo_name}}\u0026#34; And inside your pipeline, you are referencing them for the git-clone to reuse :\n[...] workspaces:  - name basic-auth params:  - name: repo_url  - name: revision [...] tasks:  workspaces:  - name: basic-auth  workspace: basic-auth  [...]  tasks:  - name: git-clone-from-catalog  taskRef:  name: git-clone  params:  - name: url  value: $(params.repo_url)  - name: revision  value: $(params.revision) The git-clone task will pick up the basic-auth (optional) workspace and automatically use it to be able to clone the private repository.\nYou can see as well a full example here\nThis behavior can be disabled by configuration the secret-auto-create key inside the Pipelines-as-Code Configmap.\nPipelines as Code resolver #  If Pipelines as Code sees a PipelineRun with a reference to a Task or a Pipeline, it will tries to resolves it as a single PipelineRun with an embedded PipelineSpec to a PipelineRun.\nIt will as well transform the Pipeline Name to a generateName based on the Pipeline name as well.\nThis allows you to have multiple runs in the same namespace from the same PipelineRun with no risk of conflicts.\nEverything that runs your pipelinerun and its references need to be inside the .tekton/ directory or referenced via a remote task (see below on how the remote tasks are referenced).\nIf you have a taskRef to a task located in the .tekton/ directory it will be automatically embedded even if it\u0026rsquo;s not in the annotations.\nIf you have a reference to a ClusterTask or a Bundle (Task or Pipeline) the resolver will just use them as is and would not try to do anything with it.\nIf pipelines as code cannot resolve the referenced tasks in the Pipeline or PipelineSpec it will fails before applying the pipelinerun onto the cluster.\nIf you need to test your PipelineRun locally before sending it in a PR, you can use the resolve command from the tkn-pac CLI See the --help of the command to learn about how to use it.\nRemote Task support #  Pipelines as Code support fetching remote tasks from remote location via annotations on PipelineRun.\nIf the resolver sees a PipelineRun referencing a remote task via its name in a Pipeline or a PipelineSpec it will automatically inlines it.\nAn annotation to a remote task looks like this :\npipelinesascode.tekton.dev/task: \u0026#34;git-clone\u0026#34; or multiple tasks via an array :\npipelinesascode.tekton.dev/task: [\u0026#34;git-clone\u0026#34;, \u0026#34;pylint\u0026#34;] this installs the git-clone task from the tekton hub repository via its API.\nYou can have multiple tasks in there if you separate them by a comma ,:\npipelinesascode.tekton.dev/task: \u0026#34;[git-clone, golang-test, tkn]\u0026#34; You can have multiple lines if you add a -NUMBER suffix to the annotation, for example :\n pipelinesascode.tekton.dev/task: \u0026#34;git-clone\u0026#34;  pipelinesascode.tekton.dev/task-1: \u0026#34;golang-test\u0026#34;  pipelinesascode.tekton.dev/task-2: \u0026#34;tkn\u0026#34; By default Pipelines as Code will interpret the string as the latest task to grab from tekton hub.\nIf you want to have a specific version of the task, you can add a colon : to the string and a version number, like in this example :\n pipelinesascode.tekton.dev/task: \u0026#34;[git-clone:0.1]\u0026#34; # will install git-clone 0.1 from tekton.hub If you have a string starting with http:// or https://, Pipelines as Code will fetch the task directly from that remote url :\n pipelinesascode.tekton.dev/task: \u0026#34;[https://raw.githubusercontent.com/tektoncd/catalog/main/task/git-clone/0.3/git-clone.yaml]\u0026#34; Additionally you can as well a reference to a task from a yaml file inside your repo if you specify the relative path to it, for example :\npipelinesascode.tekton.dev/task: \u0026#34;[.tekton/tasks/git-clone.yaml]\u0026#34; will grab the .tekton/tasks/git-clone.yaml from the current repository on the SHA where the event come from (i.e: the current pull request or the current branch push).\nIf there is any error fetching those resources, Pipelines as Code will error out and not process the pipeline.\nIf the object fetched cannot be parsed as a Tekton Task it will error out.\nRunning the Pipeline #    A user create a Pull Request.\n  Pipelines as Code picks the event and matches to a Repo CRD installed on the cluster.\n  The user would only be allowed to run the CI if :\n The user is the owner of the repository. The user is a collaborator on the repository. The user is a public member on the organization of the repository.    If the user is sending the Pull Request is inside an OWNER file located in the repository root on the main branch (the main branch as defined in the Github configuration for the repo) and added to either approvers or reviewers sections like this :\n  approvers:  - approved then the user approved will be allowed.\n  If the sender of a PR is not allowed to run CI but one of allowed user issue a /ok-to-test in any line of a comment the PR will be allowed to run CI.\n  If the user is allowed, Pipelines as Code will start creating the PipelineRun in the target user namespace.\n  The user can follow the execution of your pipeline with the tkn cli :\n  tkn pr logs -n my-pipeline-ci -Lf Or with the OpenShift console inside your namespace to follow the pipelinerun execution via the URL provided on the \u0026ldquo;Checks\u0026rdquo; tab if you run with Github App.\nStatus #  GitHub #  When the pipeline finishes the status will be added in the Github Check tabs with a short recap of how long each task of your pipeline took and the output of tkn pr describe.\nIf there was a failure you can click on the \u0026ldquo;Re-Run\u0026rdquo; button on the left to rerun the Pipeline or you can issue a issue comment with a line starting and finishing with the string /retest to ask Pipelines as Code to retest the current PR.\nExample :\nThanks for contributing! This is a much needed bugfix! ❤️ The failure is not with your PR but seems to be an infra issue.  /retest CRD #  Status of your pipeline execution is stored inside the Repo CustomResource :\n% kubectl get repo -n pipelines-as-code-ci NAME URL NAMESPACE SUCCEEDED REASON STARTTIME COMPLETIONTIME pipelines-as-code-ci https://github.com/openshift-pipelines/pipelines-as-code pipelines-as-code-ci True Succeeded 59m 56m The last 5 status are stored inside the CustomResource and can be accessed directly like this :\n% kubectl get repo -n pipelines-as-code-ci -o json|jq .items[].pipelinerun_status [  {  \u0026#34;completionTime\u0026#34;: \u0026#34;2021-05-05T11:00:05Z\u0026#34;,  \u0026#34;conditions\u0026#34;: [  {  \u0026#34;lastTransitionTime\u0026#34;: \u0026#34;2021-05-05T11:00:05Z\u0026#34;,  \u0026#34;message\u0026#34;: \u0026#34;Tasks Completed: 3 (Failed: 0, Cancelled 0), Skipped: 0\u0026#34;,  \u0026#34;reason\u0026#34;: \u0026#34;Succeeded\u0026#34;,  \u0026#34;status\u0026#34;: \u0026#34;True\u0026#34;,  \u0026#34;type\u0026#34;: \u0026#34;Succeeded\u0026#34;  }  ],  \u0026#34;pipelineRunName\u0026#34;: \u0026#34;pipelines-as-code-test-run-7tr84\u0026#34;,  \u0026#34;startTime\u0026#34;: \u0026#34;2021-05-05T10:53:43Z\u0026#34;  },  {  \u0026#34;completionTime\u0026#34;: \u0026#34;2021-05-05T11:20:18Z\u0026#34;,  \u0026#34;conditions\u0026#34;: [  {  \u0026#34;lastTransitionTime\u0026#34;: \u0026#34;2021-05-05T11:20:18Z\u0026#34;,  \u0026#34;message\u0026#34;: \u0026#34;Tasks Completed: 3 (Failed: 0, Cancelled 0), Skipped: 0\u0026#34;,  \u0026#34;reason\u0026#34;: \u0026#34;Succeeded\u0026#34;,  \u0026#34;status\u0026#34;: \u0026#34;True\u0026#34;,  \u0026#34;type\u0026#34;: \u0026#34;Succeeded\u0026#34;  }  ],  \u0026#34;pipelineRunName\u0026#34;: \u0026#34;pipelines-as-code-test-run-2fhhg\u0026#34;,  \u0026#34;startTime\u0026#34;: \u0026#34;2021-05-05T11:11:20Z\u0026#34;  },  [...] Notifications #  Notifications is not handled by Pipelines as Code, the only place where we notify a status in a interface is when we do a Pull Request on for example the Github checks interface to show the results of the pull request.\nIf you need some other type of notification you can use the finally feature of tekton pipeline .\nHere is an example task to send a slack message on failures (or success if you like) :\nhttps://github.com/chmouel/tekton-slack-task-status\nThe push pipeline of Pipelines as Code use this task, you can see the example here :\n.tekton/push.yaml\nCLI #  Pipelines as Code provide a CLI which is design to work as tkn plugin. See the installation instruction on how to install and use it here.\n"},{"id":4,"href":"/docs/cli/","title":"CLI","section":"Docs","content":"Pipelines as Code CLI #  Pipelines as Code provide a powerful CLI designed to work with tkn plugin. tkn-pac allows you to :\n bootstrap: quickly bootstrap a Pipelines as Code installation. create: create a new Pipelines as Code Repository. generate: generate a simple pipelinerun to get you started with Pipelines as Code. list: list Pipelines as Code Repositories. describe: describe a Pipelines as Code Repository and the runs associated with it. resolve: Resolve a pipelinerun as if it were executed by pipelines as code on service.  Install #  Binary releases #  You can grab the latest binary directly from the releases page.\nDev release #  If you want to install from the git repository you can just do :\ngo install github.com/openshift-pipelines/pipelines-as-code/cmd/tkn-pac Brew release #  On LinuxBrew or OSX brew you can simply add the Brew tap to have the tkn-pac plugin and its completion installed :\nbrew install openshift-pipelines/pipelines-as-code/tektoncd-pac and simply upgrade with :\nbrew upgrade openshift-pipelines/pipelines-as-code/tektoncd-pac Container #  tkn-pac is as well available as a container :\n# use docker podman run -e KUBECONFIG=/tmp/kube/config -v ${HOME}/.kube:/tmp/kube \\  -it quay.io/openshift-pipeline/pipelines-as-code tkn-pac help Commands #  bootstrap #  tkn pac bootstrap command will help you getting started installing and configuring Pipelines as code. It currently supports the following providers:\n Github application on public Github Github application on Github Enterprise  It will start checking if you have installed Pipelines as Code and if not it will ask you if you want to install (with kubectl) the latest stable release. If you add the flag --nightly it will install the latest code ci release.\nBootstrap detect the OpenShift Route automatically associated to the Pipelines as code controller service. If you don\u0026rsquo;t have an OpenShift install it will ask you for your public URL (ie: an ingress spec url) You can override the URL with the flag --route-url.\nbootstrap github-app #  If you only want to create the Github application you can use tkn pac bootstrap github-app directly which would skip the installation and only create the github application and the secret with all the information needed in the pipelines-as-code namespace.\nRepository creation #  tkn pac repo create \u0026ndash; will create a new Pipelines as Code Repository and a namespace where the pipelineruns command. It will launch the tkn pac generate command right after the creation.\nRepository Listing #  tkn pac repo list \u0026ndash; will list all the Pipelines as Code Repositories and display the last status of the runs associated with it.\nRepository Describe #  tkn pac repo describe \u0026ndash; will describe a Pipelines as Code Repository and the runs associated with it.\nOn modern terminal (ie: iTerm2, Windows Terminal, gnome-terminal etc..) the links are clickable via control+click or ⌘+click and will open the browser to the UI URL to see the Pipelinerun associated with it.\nGenerate #  tkn pac generate: will generate a simple pipelinerun to get you started with Pipelines as Code. It will try to be as smart as possible by detecting the current git information if you run the command from your source code.\nIt has some basic language detection and add extra task depending of the language. For example if it detects a file named setup.py at the repository root it will add the pylint task to the generated pipelinerun.\nResolve #  tkn-pac resolve: will run a pipelinerun as if it were executed by pipelines as code on service.\nFor example if you have a pipelinerun in the .tekton/pull-request.yaml file you can run the command tkn-pac resolve to see it running:\ntkn pac resolve -f .tekton/pull-request.yaml|kubectl apply -f - Combined with a kubernetes install running on your local machine (likeCode Ready Containers or Kubernetes Kind ) you can see your run in action without having to generate a new commit.\nIf you run the command from your source code repository it will try to detect the current git information and resolve the parameters like current revision or branch. You can override those params with the -p option. For example if you want to use a git branch as revision and another repo name than the current repo name you can just use :\ntkn pac resolve -f .tekton/pr.yaml -p revision=main -p repo_name=othername\n-f can as well accept a directory path instead of just a filename and grab every yaml/yml from the directory.\nYou can specify multiple -f on the command line.\nYou need to make sure that git-clone task (if you use it) can access the repository to the SHA. Which mean if you test your current source code you need to push it first tbefore using tkn pac resolve|kubectl apply.\nCompared with running directly on CI, you need to explicitely specify the list of filenames or directory where you have the templates.\n"},{"id":5,"href":"/docs/install/gitlab/","title":"Gitlab","section":"Installation","content":"Install Pipelines-as-Code for Gitlab #  Pipelines-As-Code supports Gitlab via a webhook.\nFollowing the infrastructure installation:\n  You will have to generate a personal token as the manager of the Org or the Project, follow the steps here :\nhttps://docs.gitlab.com/ee/user/profile/personal_access_tokens.html\nNote: You can create a token scoped only to the project. Since the token needs to be able to have api access to the forked repository from where the MR come from, it will fail to do it with a project scoped token. We try to fallback nicely by showing the status of the pipeline directly as comment of the the Merge Request.\n  Go to your project and click on Settings and \u0026ldquo;Webhooks\u0026rdquo; from the sidebar on the left.\n  Set the payload URL to the event listener public URL. On OpenShift you can get the public URL of the Pipelines-as-Code controller like this :\necho https://$(oc get route -n pipelines-as-code el-pipelines-as-code-interceptor -o jsonpath=\u0026#39;{.spec.host}\u0026#39;)   Add a secret or generate a random one with this command :\nopenssl rand -hex 20 ``   Refer to this screenshot on how to configure the Webhook.\nThe individual events to select are :\n Merge request Events Push Events Note Events    On your cluster you need create the webhook secret as generated previously in the pipelines-as-code namespace.\n  kubectl -n pipelines-as-code create secret generic pipelines-as-code-secret \\  --from-literal webhook.secret=\u0026#34;$WEBHOOK_SECRET_AS_GENERATED\u0026#34;   You are now able to create a Repository CRD. The repository CRD will have a Secret that contains the Personal token as generated and Pipelines as Code will know how to use it for Gitlab API operations.\n  First create the secret with the personal token in the target-namespace (where you are planning to run your pipeline CI) :\nkubectl -n target-namespace create secret generic gitlab-personal-token \\  --from-literal token=\u0026#34;TOKEN_AS_GENERATED_PREVIOUSLY\u0026#34;   And now create Repository CRD with the secret field referencing it.\n  Here is an example of a Repository CRD :\n--- apiVersion: \u0026#34;pipelinesascode.tekton.dev/v1alpha1\u0026#34; kind: Repository metadata:  name: my-repo  namespace: target-namespace spec:  url: \u0026#34;https://gitlab.com/group/project\u0026#34;  git_provider:  secret:  name: \u0026#34;gitlab-personal-token\u0026#34;  # Set this if you have a different key in your secret  # key: \u0026#34;token\u0026#34; Notes #    Private instance are automatically detected, no need to specify the api url. Unless you want to override it then you can simply add it to the spec.git_provider.url field.\n  git_provider.secret cannot reference a secret in another namespace, Pipelines as code assumes always it will be the same namespace as where the repository has been created.\n  "},{"id":6,"href":"/docs/install/bitbucket_cloud/","title":"Bitbucket Cloud","section":"Installation","content":"Install Pipelines-As-Code for Bitbucket Cloud #  Pipelines-As-Code has a full support on Bitbucket Cloud on https://bitbucket.org as Webhook.\nFollowing the infrastructure installation :\n You will have to generate an app password for Pipelines-as-Code Bitbucket API operations. Follow this guide to create an app password :  https://support.atlassian.com/bitbucket-cloud/docs/app-passwords/\nAdd those permissions to the token :\nimage\nMake sure you note somewhere the generated token or otherwise you will have to recreate it.\n  Go to you \u0026ldquo;Repository setting\u0026rdquo; tab on your Repository and click on the WebHooks tab and \u0026ldquo;Add webhook\u0026rdquo; button.\n  Set a Title (i.e: Pipelines as Code)\n  Set the URL to the event listener public URL. On OpenShift you can get the public URL of the Pipelines-as-Code controller like this :\necho https://$(oc get route -n pipelines-as-code el-pipelines-as-code-interceptor -o jsonpath=\u0026#39;{.spec.host}\u0026#39;)   Refer to this screenshot on how to configure the Webhook. The individual events to select are :\n Repository -\u0026gt; Push Pull Request -\u0026gt; Created Pull Request -\u0026gt; Updated Pull Request -\u0026gt; Comment created Pull Request -\u0026gt; Comment updated    You are now able to create a Repository CRD. The repository CRD will have a Secret and Username that contains the App Password as generated and Pipelines as Code will know how to use it for Bitbucket API operations.\n First create the secret with the app password in the target-namespace :  kubectl -n target-namespace create secret generic bitbucket-app-password \\  --from-literal token=\u0026#34;TOKEN_AS_GENERATED_PREVIOUSLY\u0026#34;   And now create Repository CRD with the secret field referencing it.\n  Here is an example of a Repository CRD :\n    --- apiVersion: \u0026#34;pipelinesascode.tekton.dev/v1alpha1\u0026#34; kind: Repository metadata:  name: my-repo  namespace: target-namespace spec:  url: \u0026#34;https://bitbucket.com/workspace/repo\u0026#34;  branch: \u0026#34;main\u0026#34;  git_provider:  user: \u0026#34;yourbitbucketusername\u0026#34;  secret:  name: \u0026#34;bitbucket-cloud-token\u0026#34;  # Set this if you have a different key in your secret  # key: \u0026#34;token\u0026#34; Bitbucket Cloud Notes #    git_provider.secret cannot reference a secret in another namespace, Pipelines as code assumes always it will be the same namespace as where the repository has been created.\n  tkn-pac create and bootstrap is not supported on Bitbucket Server.\n  There is no Webhook secret support in Bitbucket Cloud. To be able to secure the payload and not let a user hijack the CI, Pipelines-as-Code will fetch the ip addresses list from https://ip-ranges.atlassian.com/ and make sure the webhook only comes from the Bitbucket Cloud IPS.\n  If you want to add some ips address or networks you can add them to the key bitbucket-cloud-additional-source-ip in the pipelines-as-code configmap in the pipelines-as-code namespace. You can added multiple network or ips separated by a comma.\n  If you want to disable this behavior you can set the key bitbucket-cloud-check-source-ip to false in the pipelines-as-code configmap in the pipelines-as-code namespace.\n  You can only reference user by ACCOUNT_ID in owner file, see here for the reasoning :\n  https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#introducing-atlassian-account-id-and-nicknames\n"},{"id":7,"href":"/docs/install/bitbucket_server/","title":"Bitbucket Server","section":"Installation","content":"Install Pipelines-As-Code for Bitbucket Server #  Pipelines-As-Code has a full support of Bitbucket Server.\nFollowing the infrastructure installation :\n You will have to generate a personal token as the manager of the Project, follow the steps here :  https://confluence.atlassian.com/bitbucketserver/personal-access-tokens-939515499.html\nThe token will need to have the PROJECT_ADMIN and REPOSITORY_ADMIN permissions.\nNote that the token needs to be able to have access to the forked repository in pull requests or it would not be able to process and access the pull request.\nMake sure you note somewhere the generated token or otherwise you will have to recreate it.\n Create a Webhook on the repository following this guide :  https://support.atlassian.com/bitbucket-cloud/docs/manage-webhooks/\n Add a Secret or generate a random one with :   openssl rand -hex 20   Set the URL to the event listener public URL. On OpenShift you can get the public URL of the Pipelines-as-Code route like this :\necho https://$(oc get route -n pipelines-as-code el-pipelines-as-code-interceptor -o jsonpath=\u0026#39;{.spec.host}\u0026#39;)   Install the secret in the pipelines-as-code namespace (we currently only supports one webhook secret per cluster ) :\n  kubectl -n pipelines-as-code create secret generic pipelines-as-code-secret \\  --from-literal webhook.secret=\u0026#34;$WEBHOOK_SECRET_AS_GENERATED\u0026#34;   Refer to this screenshot on which events to handle on the Webhook. The individual events to select are :\n Repository -\u0026gt; Push Repository -\u0026gt; Modified Pull Request -\u0026gt; Opened Pull Request -\u0026gt; Source branch updated Pull Request -\u0026gt; Comments added    And finally create Repository CRD with the secret field referencing it.\n Here is an example of a Repository CRD :    --- apiVersion: \u0026#34;pipelinesascode.tekton.dev/v1alpha1\u0026#34; kind: Repository metadata:  name: my-repo  namespace: target-namespace spec:  url: \u0026#34;https://bitbucket.com/workspace/repo\u0026#34;  git_provider:  url: \u0026#34;https://bitbucket.server.api.url\u0026#34;  user: \u0026#34;yourbitbucketusername\u0026#34;  secret:  name: \u0026#34;bitbucket-server-token\u0026#34;  # Set this if you have a different key in your secret  # key: \u0026#34;token\u0026#34; Notes #    git_provider.secret cannot reference a secret in another namespace, Pipelines as code assumes always it will be the same namespace as where the repository has been created.\n  tkn-pac create and bootstrap is not supported on Bitbucket Server.\n  You can only reference user by the ACCOUNT_ID in owner file.\n  "},{"id":8,"href":"/dev/release-process/","title":"Pipelines as Code Release Process","section":"Devs","content":"Release process for Pipelines as Code #   Clear out the PR needed to be merged. Wait that CI is connected. Make sure the CI PAC cluster is up. Make sure you have gpg signing setup for your commits. You need to install python package semver :  pip3 install --user semver  Use this script which should do most things :  ./hack/make-release.sh   Choose a version if it\u0026rsquo;s a major release/minor or patch release and let it push the new tags which should kick off pipelines as code release pipelines.\n  When it started you can follow it on the pac cluster :\n  tkn pr logs -n pipelines-as-code-ci -Lf\n  After a while (gorelease takes somet ime) If everything is fine you should have the new version set as pre-release in github.com/openshift-pipelines/pipelines-as-code/releases\n  Edit the release like the other releases has been done with a snippet of the highlight of the release.\n  Announce it on Slack (upstream/downstream) and twitter.\n  Packages #   Arch AUR: Ping chmouel for an update  Issues you may see #   Sometime there may be some issues with system or others. If you need to rekick the release process you need to :   git push --delete git@github.com:openshift-pipelines/pipelines-as-code release-1.2.3  git push --delete git@github.com:openshift-pipelines/pipelines-as-code 1.2.3  git tag --sign --force 1.2.3  git push git@github.com:openshift-pipelines/pipelines-as-code 1.2.3  Some issues may be with the github token which may be expired or badly generated with a \\n. Some other issues if you didn\u0026rsquo;t do a git fetch -a origin before tagging so you don\u0026rsquo;t have the latest commits from origin/main  "}]